<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tsdst.mcmc &#8212; tsdst 1.0.11 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          tsdst</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Pages</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for tsdst.mcmc</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">la</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">loggamma</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">chi2</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">toeplitz</span><span class="p">,</span> <span class="n">solve</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">dt</span>

<span class="kn">from</span> <span class="nn">.tmath</span> <span class="kn">import</span> <span class="n">cov2cor</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">pretty_print_time</span>
<span class="kn">from</span> <span class="nn">.distributions</span> <span class="kn">import</span> <span class="n">qnorm_approx</span>


<span class="k">def</span> <span class="nf">_updateProgBarMCMC</span><span class="p">(</span><span class="n">curIter</span><span class="p">,</span> <span class="n">totalIter</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">ar</span><span class="p">,</span> <span class="n">barLength</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Custom progress bar to output MCMC chain progress.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    curIter : int</span>
<span class="sd">        Current iteration.</span>
<span class="sd">    totalIter : int</span>
<span class="sd">        Total iterations.</span>
<span class="sd">    t0 : float</span>
<span class="sd">        Timestamp of when the process started (timestamp as float).</span>
<span class="sd">    ar : float</span>
<span class="sd">        Acceptance Ratio.</span>
<span class="sd">    barLength : int, optional</span>
<span class="sd">        The character length of the progress bar. The default is 20.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;Working...&quot;</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">curIter</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">totalIter</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">progress</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">progress</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;Finished!...&quot;</span>
    <span class="n">block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">barLength</span><span class="o">*</span><span class="n">progress</span><span class="p">))</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">Percent: [</span><span class="si">{0}</span><span class="s2">] </span><span class="si">{1:.2f}% i</span><span class="s2">ter: </span><span class="si">{2}</span><span class="s2">/</span><span class="si">{3}</span><span class="s2">, </span><span class="si">{4}</span><span class="s2"> Elapsed: </span><span class="si">{5}</span><span class="s2">, Est: </span><span class="si">{6}</span><span class="s2">, Accept. Rate: </span><span class="si">{7}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="s2">&quot;#&quot;</span><span class="o">*</span><span class="n">block</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="p">(</span><span class="n">barLength</span> <span class="o">-</span> <span class="n">block</span><span class="p">),</span> 
        <span class="nb">round</span><span class="p">(</span><span class="n">progress</span><span class="o">*</span><span class="mf">100.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">curIter</span><span class="p">,</span> <span class="n">totalIter</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">pretty_print_time</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">dt</span><span class="p">()),</span>
        <span class="n">pretty_print_time</span><span class="p">((</span><span class="n">dt</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="n">curIter</span> <span class="o">*</span> <span class="p">(</span><span class="n">totalIter</span> <span class="o">-</span> <span class="n">curIter</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">progress</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        

<div class="viewcode-block" id="applyMCMC"><a class="viewcode-back" href="../../generated/tsdst.mcmc.applyMCMC.html#tsdst.mcmc.applyMCMC">[docs]</a><span class="k">def</span> <span class="nf">applyMCMC</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">algo</span><span class="p">,</span> <span class="n">algoOpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postArgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">sd</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">max_tries</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function iteratively applies the MCMC initialization. Since the MCMC</span>
<span class="sd">    algorithms used here involve a cholesky decomposition, the methods</span>
<span class="sd">    sometimes get stuck with a covaraince matrix that is not positive definite.</span>
<span class="sd">    This will attempt to jitter the covariance matrix until it can initialize</span>
<span class="sd">    properly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    st : numpy array</span>
<span class="sd">        An array of the parameter starting values.</span>
<span class="sd">    ni : int</span>
<span class="sd">        NUmber of MCMC iterations.</span>
<span class="sd">    lp : function</span>
<span class="sd">        Function for the log posterior.</span>
<span class="sd">    algo : function</span>
<span class="sd">        MCMC algorithm to be performed.</span>
<span class="sd">    algoOpts : dict, optional</span>
<span class="sd">        Specific options for the MCMC algorithm. The default is None.</span>
<span class="sd">    postArgs : dict, optional</span>
<span class="sd">        Specific options for the posterior function. The default is None.</span>
<span class="sd">    sd : float, optional</span>
<span class="sd">        The standard deviation of the normal distribution used to draw the</span>
<span class="sd">        jitter amount from. In other words, the jittered covariance is the </span>
<span class="sd">        covaraince matrix plus a random draw X, where X~N(0, sd). </span>
<span class="sd">        The default is 0.02.</span>
<span class="sd">    max_tries : int, optional</span>
<span class="sd">        The max number of times to try and jitter before admitting defeat.</span>
<span class="sd">        If the jitter fails, the reason or the covaraince matrix not being</span>
<span class="sd">        positive definite may not be due to randomness, and may require</span>
<span class="sd">        a re-evaluation of the problem space. The default is 100.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raised when cholesky decomposition fails after max_tries.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : tuple</span>
<span class="sd">        Returns tuple containing the MCMC results.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">postArgs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">postArgs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">try_num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">not_successful</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">lns</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">while</span> <span class="n">not_successful</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">try_num</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">lns</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">algo</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">st</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">ni</span><span class="p">,</span> <span class="n">lpost</span><span class="o">=</span><span class="n">lp</span><span class="p">,</span> <span class="n">postArgs</span><span class="o">=</span><span class="n">postArgs</span><span class="p">,</span>
                       <span class="n">options</span><span class="o">=</span><span class="n">algoOpts</span><span class="p">)</span>
            <span class="n">not_successful</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="n">try_num</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">try_num</span> <span class="o">&gt;=</span> <span class="n">max_tries</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cholesky Decomposition was not successful after &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_tries</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; tries. Try new starting values&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of Cholesky tries: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">try_num</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res</span>              </div>


<span class="c1"># For upper triangle rank one update</span>
<div class="viewcode-block" id="cholupdate"><a class="viewcode-back" href="../../generated/tsdst.mcmc.cholupdate.html#tsdst.mcmc.cholupdate">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">cholupdate</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Upper triangle, rank one update for cholesky decomposed matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L : numpy array (float)</span>
<span class="sd">        The upper-triangular decomposed matrix, shape=(N, N).</span>
<span class="sd">    x : numpy array (float)</span>
<span class="sd">        The values being added to L, shape=(N, ).</span>
<span class="sd">    update : bool, optional</span>
<span class="sd">        Perform an update (as opposed to a downdate). The default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L : numpy array</span>
<span class="sd">        Return updated L matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
        <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span><span class="p">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">])</span> <span class="o">/</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span><span class="p">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">])</span> <span class="o">/</span> <span class="n">c</span>
            <span class="n">x</span><span class="p">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="p">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">p</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">L</span></div>


<div class="viewcode-block" id="adaptive_mcmc"><a class="viewcode-back" href="../../generated/tsdst.mcmc.adaptive_mcmc.html#tsdst.mcmc.adaptive_mcmc">[docs]</a><span class="k">def</span> <span class="nf">adaptive_mcmc</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">postArgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A random walk metropolis algorithm that adaptively tunes the covariance</span>
<span class="sd">    matrix.</span>

<span class="sd">    Based on methods by Rosenthal (who improved on Haario\&#39;s method).</span>
<span class="sd">    The method by Rosenthal is sometimes referred to as Adaptive Mixture</span>
<span class="sd">    Metropolis, while the algorithm by Haario is called Adaptive Metropolis and</span>
<span class="sd">    is generally considered to be the historically first adaptive Metropolis</span>
<span class="sd">    algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : numpy array</span>
<span class="sd">        Starting values for the MCMC.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of iterations.</span>
<span class="sd">    lpost : function</span>
<span class="sd">        Log posterior function.</span>
<span class="sd">    postArgs : dict</span>
<span class="sd">        Extra arguments for the log posterior function. The default is :obj:`None` . Parameter options include</span>

<span class="sd">            - beta \: (:obj:`float`) Between 0 and 1. Decides the proportion to sample for each section of the mixture \</span>
<span class="sd">            distribution. A mixture distribution is essentially like adding two distributions together. However, to \</span>
<span class="sd">            avoid some complicated math, one way to sample from a mixture of two distributions is to use a trick, \</span>
<span class="sd">            namely, to first sample from a uniform distribution between 0, 1, and then evaluate whether that value \</span>
<span class="sd">            is above some threshold (beta in this case). If it is, sample from the first distribution, otherwise, \</span>
<span class="sd">            sample from the second.</span>
<span class="sd">            - progress \: (:obj:`bool`) Whether to display progress bar.</span>
<span class="sd">            - prev_vals \: (:obj:`dict`) The previous values of the last run, namely:</span>

<span class="sd">                - chol2 \: (:obj:`numpy array`) The decomposed covariance matrix of the parameters.</span>
<span class="sd">                - sumx \: (:obj:`numpy array`) The current sum of the parameter value (for each parameter)</span>
<span class="sd">                - prev_i \: (:obj:`int` or :obj:`float`) The number of samples represented in sumx. Used in averaging \</span>
<span class="sd">                sumx</span>

<span class="sd">    options : :obj:`dict`, optional</span>
<span class="sd">        Extra arguments for the MCMC algorithm, such as</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    parm : numpy array</span>
<span class="sd">        MCMC samples.</span>
<span class="sd">    prev_vals : dict</span>
<span class="sd">        The ending values of the MCMC algorithm. Useful when you want to</span>
<span class="sd">        continue where you left off.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A random walk metropolis algorithm that adaptively tunes the covariance matrix. Based on methods by Rosenthal</span>
<span class="sd">    (who improved on Haario&#39;s method). The method by Rosenthal is sometimes refered to as Adaptive Mixture Metropolis,</span>
<span class="sd">    while the algorithm by Haario is called Adaptive Metropolis and is generally considered to be the historically first</span>
<span class="sd">    adaptive Metropolis algorithm.</span>

<span class="sd">    This method is identical to a Random Walk Metropolis algorithm, except that it adapts the covariance matrix after</span>
<span class="sd">    each iteration based on the sample covariance of the entire chain up to the current iteration. The candidate values</span>
<span class="sd">    in the MCMC chain are then sampled from a mixed density distribution defined as follows:</span>

<span class="sd">    .. math:: Q_{n}(x, \\cdot) = (1 - \\beta)N(x, (2.38)^{2} \\Sigma_{n}/d) + \\beta N(x, (0.1)^{2} I_{d} / d)</span>

<span class="sd">    * :math:`Q_{n}`: The proposal distribution</span>
<span class="sd">    * :math:`N`: Normal Distribution</span>
<span class="sd">    * :math:`\\beta`: some small constant, usually 0.05</span>
<span class="sd">    * :math:`\\Sigma_{n}`: sample covariance up to the :math:`n^{th}` iteration</span>
<span class="sd">    * :math:`d`: the number of parameters</span>
<span class="sd">    * :math:`I_{d}`: the :math:`d \\times d` identity matrix</span>

<span class="sd">    To sample from any density distribution, you must first calculate the inverse cdf of the function, otherwise</span>
<span class="sd">    known as the quantile function. Assuming that there is a simple method to generate a uniform random number with</span>
<span class="sd">    range :math:`[0, 1]` (most programming languages do), then calculating a random number from any distribution is</span>
<span class="sd">    simple. First, generate the random uniform number, and use it as the input to the quantile function. However,</span>
<span class="sd">    in many practical situations (such as with the normal distribution), calculating the quantile function is</span>
<span class="sd">    non-trivial. The same is true for the above mixed density distribution. Therefore, to simplify sampling from</span>
<span class="sd">    the mixed density distribution, use a uniform random number generator to sample a number :math:`U` between</span>
<span class="sd">    :math:`[0, 1]`. Then, if :math:`U &lt; \\beta`, then sample the candidate value from :math:`N(x, (2.38)^{2} \\Sigma_{n}/d)`.</span>
<span class="sd">    Otherwise, sample from :math:`N(x, (0.1)^{2} I_{d} / d)`.</span>

<span class="sd">    To calculate :math:`\\Sigma_{n}` efficiently, the algorithm uses the :func:`cholupdate` function. Let :math:`X` be</span>
<span class="sd">    an :math:`n \\times d` matrix of `n` MCMC samples and `d` parameters. Then, the equation for population covariance can be defined as follows:</span>

<span class="sd">    .. math:: \\Sigma_n = E(X^{T}X) - E(X^{T})E(X) = \\frac{X^{T}X}{n} - \\mu^{T} \\mu</span>

<span class="sd">    The algorithm calculates the cholesky distribution of :math:`X^{T}X` for the first four samples. From that point</span>
<span class="sd">    on, :math:`X^{T}X` is updated using :func:`cholupdate` where `update=True`. If :math:`U &lt; \\beta`, then</span>
<span class="sd">    :math:`\\big( \\frac{X^{T}X}{n} - \\mu^{T} \\mu \\big)` is calculated using :func:`cholupdate(XTX/n, uTu, update=False)&lt;cholupdate&gt;`.</span>
<span class="sd">    This algorithm uses the sample covariance, which can be calculated using the following trick:</span>

<span class="sd">    .. math:: \\Big( \\frac{X^{T}X}{n} - \\mu^{T} \\mu \\Big) \\Big(\\frac{n}{n-1} \\Big)</span>

<span class="sd">    The algorithm multiplies :math:`\\Sigma_{n}` by :math:`\\frac{2.38^2}{d}`, which makes the final covariance used</span>
<span class="sd">    to create the candidate samples:</span>

<span class="sd">    .. math:: \\Sigma_{n} = \\Big( \\frac{2.38^2}{d} \\Big) \\Big( \\frac{X^{T}X}{n} - \\mu^{T} \\mu \\Big) \\Big(\\frac{n}{n-1} \\Big)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">prev_vals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;chol2&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sumx&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;prev_i&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">postArgs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">postArgs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39;beta&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;beta&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;progress&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;progress&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;prev_vals&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">prev_vals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;prev_vals&#39;</span><span class="p">])</span>
    
    <span class="n">numParams</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">size</span>
    <span class="n">sqrtNumParams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numParams</span><span class="p">)</span>
    <span class="n">parm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">niter</span><span class="p">,</span> <span class="n">numParams</span><span class="p">))</span>
    <span class="n">parm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">sumx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s1">&#39;sumx&#39;</span><span class="p">]</span>
    <span class="n">accept</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">post_old</span> <span class="o">=</span> <span class="n">lpost</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">**</span><span class="n">postArgs</span><span class="p">)</span>
    
    <span class="n">prop_dist_var</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numParams</span><span class="p">))</span> <span class="o">/</span> <span class="n">numParams</span>
    <span class="n">chol1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">prop_dist_var</span><span class="p">)</span>
    <span class="n">chol2</span> <span class="o">=</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s1">&#39;chol2&#39;</span><span class="p">]</span>
    <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">)</span>
    
    <span class="n">sumi</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s1">&#39;prev_i&#39;</span><span class="p">]</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">dt</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
        <span class="n">parm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">parm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">]</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">numParams</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">tune</span> <span class="o">=</span> <span class="n">chol1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chol2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">XXt</span> <span class="o">=</span> <span class="n">parm</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parm</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="p">])</span>
                <span class="n">chol2</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">XXt</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chol2</span> <span class="o">=</span> <span class="n">cholupdate</span><span class="p">(</span><span class="n">chol2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">]))</span>
            
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">beta</span><span class="p">:</span>
                <span class="n">tune</span> <span class="o">=</span> <span class="n">chol1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tune</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.38</span><span class="o">*</span><span class="n">cholupdate</span><span class="p">(</span><span class="n">chol2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sumi</span><span class="p">),</span> <span class="n">sumx</span><span class="o">/</span><span class="n">sumi</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrtNumParams</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sumi</span> <span class="o">/</span> <span class="p">(</span><span class="n">sumi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tune</span><span class="p">)):</span>
            <span class="n">tune</span> <span class="o">=</span> <span class="n">chol1</span>
        <span class="n">cand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">numParams</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tune</span><span class="p">)</span> <span class="o">+</span> <span class="n">parm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">]</span>
        <span class="n">post_new</span> <span class="o">=</span> <span class="n">lpost</span><span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="o">**</span><span class="n">postArgs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">post_new</span> <span class="o">-</span> <span class="n">post_old</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()):</span>
            <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="n">acceptDraw</span><span class="p">:</span>
            <span class="n">parm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
            <span class="n">post_old</span> <span class="o">=</span> <span class="n">post_new</span>
            <span class="n">accept</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">sumx</span> <span class="o">=</span> <span class="n">sumx</span> <span class="o">+</span> <span class="n">parm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span>
        <span class="n">sumi</span> <span class="o">+=</span> <span class="mf">1.0</span>
        <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
            <span class="n">_updateProgBarMCMC</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">accept</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        
    <span class="n">prev_vals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;chol2&#39;</span><span class="p">:</span> <span class="n">chol2</span><span class="p">,</span> <span class="s1">&#39;prev_i&#39;</span><span class="p">:</span> <span class="n">sumi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;sumx&#39;</span><span class="p">:</span> <span class="n">sumx</span><span class="p">}</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Acceptance Rate: &quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">accept</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">niter</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="n">parm</span><span class="p">,</span> <span class="s1">&#39;prev_vals&#39;</span><span class="p">:</span> <span class="n">prev_vals</span><span class="p">}</span></div>


<div class="viewcode-block" id="rwm_with_lap"><a class="viewcode-back" href="../../generated/tsdst.mcmc.rwm_with_lap.html#tsdst.mcmc.rwm_with_lap">[docs]</a><span class="k">def</span> <span class="nf">rwm_with_lap</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">postArgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A random walk metropolis algorithm that adaptively tunes the covariance</span>
<span class="sd">    matrix with a log-adaptive posterior.</span>
<span class="sd">    </span>
<span class="sd">    See &quot;Exploring an Adaptive Metropolis Algorithm&quot; by Ben Shaby, 2010.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : numpy array</span>
<span class="sd">        Starting values for the MCMC.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of iterations.</span>
<span class="sd">    lpost : function</span>
<span class="sd">        Log posterior function.</span>
<span class="sd">    postArgs : dict</span>
<span class="sd">        Extra arguments for the log posterior function. The default is</span>
<span class="sd">        None.</span>
<span class="sd">    options : dict, optional</span>
<span class="sd">        Extra arguments for the MCMC algorithm, namely:</span>

<span class="sd">            k : int</span>
<span class="sd">                The number of MCMC samples to generate for each evaluation.</span>
<span class="sd">            c0 : float</span>
<span class="sd">                Attenuation parameter. Default is 1.</span>
<span class="sd">            c1 : float</span>
<span class="sd">                Attenuation parameter. Default is 0.8.</span>
<span class="sd">            progress : bool</span>
<span class="sd">                Whether to display progress bar</span>
<span class="sd">            prev_vals : dict</span>
<span class="sd">                The previous values of the last run, namely:</span>

<span class="sd">                    E_0 : numpy array</span>
<span class="sd">                        the final covariance matrix</span>
<span class="sd">                    sigma_2 : float</span>
<span class="sd">                        the positive scaling parameter in the algorithm</span>
<span class="sd">                    t : int</span>
<span class="sd">                        the current iteration number</span>

<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    parm : numpy array</span>
<span class="sd">        MCMC samples.</span>
<span class="sd">    prev_vals : dict</span>
<span class="sd">        The ending values of the MCMC algorithm. Useful when you want to continue where you left off.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">postArgs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">postArgs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">k</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">c_0</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">c_1</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">prev_vals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E_0&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sigma_2&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39;k&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;c_0&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">c_0</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;c_0&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;c_1&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">c_1</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;c_1&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;progress&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;progress&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;prev_vals&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">prev_vals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;prev_vals&#39;</span><span class="p">])</span>
    
    <span class="n">numParams</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">size</span>
    <span class="n">optimal</span> <span class="o">=</span> <span class="mf">0.444</span>
    <span class="k">if</span> <span class="n">numParams</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">optimal</span> <span class="o">=</span> <span class="mf">0.234</span>
    <span class="n">T_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">niter</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T_iter</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">parm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">niter</span><span class="p">,</span> <span class="n">numParams</span><span class="p">))</span>
    <span class="n">parm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
    
    <span class="n">total_accept</span> <span class="o">=</span> <span class="n">k_accept</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">post_old</span> <span class="o">=</span> <span class="n">lpost</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">**</span><span class="n">postArgs</span><span class="p">)</span>
    
    <span class="n">sigma_2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.38</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">numParams</span>
    <span class="k">if</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s1">&#39;sigma_2&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigma_2</span> <span class="o">=</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s2">&quot;sigma_2&quot;</span><span class="p">]</span>
    
    <span class="n">E_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numParams</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s1">&#39;E_0&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">E_0</span> <span class="o">=</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s2">&quot;E_0&quot;</span><span class="p">]</span>

    <span class="n">chol</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma_2</span><span class="p">)</span><span class="o">*</span><span class="n">E_0</span><span class="p">)</span>
    <span class="n">chol_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chol</span><span class="p">)</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>
    
    <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">)</span>
    
    <span class="n">t0</span> <span class="o">=</span> <span class="n">dt</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
        <span class="n">parm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">parm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">]</span>
        <span class="n">cand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">numParams</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chol</span><span class="p">)</span> <span class="o">+</span> <span class="n">parm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">]</span>
        
        <span class="n">post_new</span> <span class="o">=</span> <span class="n">lpost</span><span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="o">**</span><span class="n">postArgs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">post_new</span> <span class="o">-</span> <span class="n">post_old</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()):</span>
            <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="n">acceptDraw</span><span class="p">:</span>
            <span class="n">parm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
            <span class="n">post_old</span> <span class="o">=</span> <span class="n">post_new</span>
            <span class="n">k_accept</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">total_accept</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
            <span class="n">_updateProgBarMCMC</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_accept</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">parm</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">):(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>
            <span class="n">mean_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="n">r_t</span> <span class="o">=</span> <span class="n">k_accept</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">Ehat_0</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">*</span> <span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">mean_X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">mean_X</span><span class="p">)))</span>
            <span class="n">gamma_1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="n">c_1</span><span class="p">)</span>
            <span class="n">gamma_2</span> <span class="o">=</span> <span class="n">c_0</span> <span class="o">*</span> <span class="n">gamma_1</span>
            <span class="n">sigma_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sigma_2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gamma_2</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_t</span> <span class="o">-</span> <span class="n">optimal</span><span class="p">)))</span>
            <span class="n">E_0</span> <span class="o">=</span> <span class="n">E_0</span> <span class="o">+</span> <span class="n">gamma_1</span><span class="o">*</span><span class="p">(</span><span class="n">Ehat_0</span> <span class="o">-</span> <span class="n">E_0</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">E_0</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">E_0</span><span class="p">)):</span>
                <span class="n">chol</span> <span class="o">=</span> <span class="n">chol_i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">chol</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma_2</span><span class="p">)</span><span class="o">*</span><span class="n">E_0</span><span class="p">)</span>
                <span class="c1">#except la.LinAlgError:</span>
                <span class="c1">#    chol = sla.sqrtm(sigma_2*E_0)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">chol</span> <span class="o">=</span> <span class="n">chol_i</span>
                    
            <span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">k_accept</span> <span class="o">=</span> <span class="mi">0</span>
            
    <span class="n">prev_vals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E_0&#39;</span><span class="p">:</span> <span class="n">E_0</span><span class="p">,</span> <span class="s1">&#39;sigma_2&#39;</span><span class="p">:</span> <span class="n">sigma_2</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">}</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Acceptance Rate: &quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_accept</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">niter</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="n">parm</span><span class="p">,</span> <span class="s1">&#39;prev_vals&#39;</span><span class="p">:</span> <span class="n">prev_vals</span><span class="p">}</span></div>


<div class="viewcode-block" id="rwm"><a class="viewcode-back" href="../../generated/tsdst.mcmc.rwm.html#tsdst.mcmc.rwm">[docs]</a><span class="k">def</span> <span class="nf">rwm</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">postArgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A random walk metropolis algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : numpy array</span>
<span class="sd">        Starting values for the MCMC.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of iterations.</span>
<span class="sd">    lpost : function</span>
<span class="sd">        Log posterior function.</span>
<span class="sd">    postArgs : dict</span>
<span class="sd">        Extra arguments for the log posterior function. The default is</span>
<span class="sd">        None.</span>
<span class="sd">    options : dict, optional</span>
<span class="sd">        Extra arguments for the MCMC algorithm, namely:</span>

<span class="sd">            E : numpy array</span>
<span class="sd">                The covariance matrix</span>
<span class="sd">            progress : bool</span>
<span class="sd">                Whether to display progress bar</span>
<span class="sd">            prev_vals : dict</span>
<span class="sd">                The previous values of the last run, namely:</span>

<span class="sd">                    E_0 : numpy array</span>
<span class="sd">                        the final covaraince matrix</span>

<span class="sd">        The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    parm : numpy array</span>
<span class="sd">        MCMC samples.</span>
<span class="sd">    prev_vals : dict</span>
<span class="sd">        The ending values of the MCMC algorithm. Useful when you want to</span>
<span class="sd">        continue where you left off.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">postArgs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">postArgs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">numParams</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">size</span>
    
    <span class="n">prev_vals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E_0&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mf">2.38</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">numParams</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numParams</span><span class="p">))}</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39;E&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;progress&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;progress&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;prev_vals&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">prev_vals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;prev_vals&#39;</span><span class="p">])</span>
    
    <span class="n">parm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">niter</span><span class="p">,</span> <span class="n">numParams</span><span class="p">))</span>
    <span class="n">parm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
    
    <span class="n">accept</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">post_old</span> <span class="o">=</span> <span class="n">lpost</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">**</span><span class="n">postArgs</span><span class="p">)</span>
    
    <span class="n">E</span> <span class="o">=</span> <span class="n">prev_vals</span><span class="p">[</span><span class="s1">&#39;E_0&#39;</span><span class="p">]</span>
    <span class="n">chol</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    
    <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">)</span>
    
    <span class="n">t0</span> <span class="o">=</span> <span class="n">dt</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
        <span class="n">parm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">parm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">]</span>
        <span class="n">cand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">numParams</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chol</span><span class="p">)</span> <span class="o">+</span> <span class="n">parm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">]</span>
        
        <span class="n">post_new</span> <span class="o">=</span> <span class="n">lpost</span><span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="o">**</span><span class="n">postArgs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">post_new</span> <span class="o">-</span> <span class="n">post_old</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()):</span>
            <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="n">acceptDraw</span><span class="p">:</span>
            <span class="n">parm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
            <span class="n">post_old</span> <span class="o">=</span> <span class="n">post_new</span>
            <span class="n">accept</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">acceptDraw</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
            <span class="n">_updateProgBarMCMC</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">accept</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    
    <span class="n">prev_vals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E_O&#39;</span><span class="p">:</span> <span class="n">E</span><span class="p">}</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Acceptance Rate: &quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">accept</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">niter</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="n">parm</span><span class="p">,</span> <span class="s1">&#39;prev_vals&#39;</span><span class="p">:</span> <span class="n">prev_vals</span><span class="p">}</span></div>


<div class="viewcode-block" id="samp_size_calc_raftery"><a class="viewcode-back" href="../../generated/tsdst.mcmc.samp_size_calc_raftery.html#tsdst.mcmc.samp_size_calc_raftery">[docs]</a><span class="k">def</span> <span class="nf">samp_size_calc_raftery</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.95</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate needed sample size for Raftery evaluation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : float, optional</span>
<span class="sd">        Quantile of interest (in terms of percentile, i.e. between 0 and 1).</span>
<span class="sd">        The default is 0.025.</span>
<span class="sd">    r : float, optional</span>
<span class="sd">        Accuracy. The default is 0.005.</span>
<span class="sd">    s : float, optional</span>
<span class="sd">        Probability. The default is 0.95.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phi : float</span>
<span class="sd">        Phi parameter in Raftery evaluation.</span>
<span class="sd">    nmin : int</span>
<span class="sd">        Minimum number of samples needed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">qnorm_approx</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">s</span><span class="p">))</span>
    <span class="n">nmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">phi</span><span class="p">,</span> <span class="n">nmin</span></div>


<span class="k">def</span> <span class="nf">lag</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translated from R&#39;s mcmcse package</span>
<span class="sd">    </span>
<span class="sd">    Returns the lag window value for the corresponding window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : int</span>
<span class="sd">        Current block number.</span>
<span class="sd">    b : int</span>
<span class="sd">        Number of blocks.</span>
<span class="sd">    method : str</span>
<span class="sd">        Either `bartlett` or None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int, float</span>
<span class="sd">        Lag window.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bartlett&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">s</span><span class="o">/</span><span class="n">b</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">s</span><span class="o">/</span><span class="n">b</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>


<span class="k">def</span> <span class="nf">adjust_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">9</span><span class="o">/</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translated from R&#39;s mcmcse package.</span>
<span class="sd">    </span>
<span class="sd">    Function adjusts a non-positive definite estimator to be positive definite.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : numpy array</span>
<span class="sd">        A symmetric pxp matrix, usually a covarince matrix.</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of observations in the original atrix.</span>
<span class="sd">    epsilon : float, optional</span>
<span class="sd">        The adjustment size. If None, sqrt(log(N)/p).</span>
<span class="sd">        The default is None.</span>
<span class="sd">    b : float, optional</span>
<span class="sd">        The exponent on N for the adjustment. The default is 9/10.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mat_adj : numpy array</span>
<span class="sd">        Adjusted matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">epsilon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mat_adj</span> <span class="o">=</span> <span class="n">mat</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">epsilon</span><span class="o">*</span><span class="n">N</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">)</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">cov2cor</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
    <span class="n">adj_eigs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">eig_val</span><span class="p">,</span> <span class="n">adj</span><span class="p">)</span>
    <span class="n">mat_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">var</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eig_vec</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">adj_eigs</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eig_vec</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">var</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mat_adj</span>


<span class="c1">#def arp_approx(chain):</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#def batchSize(chain, method=&quot;bm&quot;, g=None):</span>
<span class="c1">#    if g is not None:</span>
<span class="c1">#        chain = np.array([g(chain[i, :]) for i in range(chain.shape[0])])</span>
<span class="c1">#    n = chain.shape[0]</span>
    


<span class="k">def</span> <span class="nf">mbmc</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translated from R&#39;s mcmcse package</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain : numpy array</span>
<span class="sd">        MCMC chain.</span>
<span class="sd">    b : int</span>
<span class="sd">        Number of blocks.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Covaraince matrix estimate.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">b</span><span class="p">))</span>
    <span class="n">y_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">block_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">mean_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="n">block_means</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">block_means</span> <span class="o">=</span> <span class="n">block_means</span><span class="o">/</span><span class="n">b</span>

    <span class="n">y_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">mean_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">y_mean</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_means</span> <span class="o">-</span> <span class="n">mean_mat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">block_means</span> <span class="o">-</span> <span class="n">mean_mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">*</span><span class="n">b</span><span class="o">/</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mobmc</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translated from R&#39;s mcmcse package</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain : numpy array</span>
<span class="sd">        MCMC chain.</span>
<span class="sd">    b : int</span>
<span class="sd">        Number of blocks.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Covariance matrix estimate.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="n">y_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">block_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">mean_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="n">block_means</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">block_means</span> <span class="o">=</span> <span class="n">block_means</span><span class="o">/</span><span class="n">b</span>

    <span class="n">y_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">mean_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">y_mean</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_means</span> <span class="o">-</span> <span class="n">mean_mat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">block_means</span> <span class="o">-</span> <span class="n">mean_mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="o">*</span><span class="n">b</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">msvec</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bartlett&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translated from R&#39;s mcmcse package.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain : numpy array</span>
<span class="sd">        MCMC chain.</span>
<span class="sd">    b : int</span>
<span class="sd">        Number of blocks.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Method to estimate covariance matrix. The default is &quot;bartlett&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Covariance matrix estimate.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tchain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">T</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">tchain</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">lag</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">dummy</span> <span class="o">+</span> <span class="n">dummy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">+=</span> <span class="n">tchain</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">/</span><span class="n">n</span>


<span class="k">def</span> <span class="nf">mcse_multi</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bm&quot;</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;sqroot&quot;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adjust</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translated from R&#39;s mcmcse package.</span>
<span class="sd">    </span>
<span class="sd">    An estimate of the Monte Carlo Standard Error, as well as the Monte Carlo</span>
<span class="sd">    estimate. Returns a covariance matrix and array for the estimates, as well </span>
<span class="sd">    as other algorithmic outputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain : numpy array</span>
<span class="sd">        The MCMC chain, where the rows are samples.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Any of `bm`, `obm`, `bartlett`, `tukey`. `bm` represents batch means</span>
<span class="sd">        estimator, `obm` represents overlapping batch means estimator with,</span>
<span class="sd">        `bartlett` and `tukey` represents the modified-Bartlett window and</span>
<span class="sd">        the Tukey-Hanning windows for spectral variance estimators.</span>
<span class="sd">        The default is &quot;bm&quot;.</span>
<span class="sd">    r : int, float, optional</span>
<span class="sd">        The Lugsail parameter, which converts a lag window into it&#39;s lugsail</span>
<span class="sd">        equivalent. Larger r implies less underestimation of `cov`, but higher</span>
<span class="sd">        variability of the estimator. r &gt; 5 is not recommended.</span>
<span class="sd">        The default is 3.</span>
<span class="sd">    size : str, or int, optional</span>
<span class="sd">        Batch size, either `sqroot`, `cuberoot`, or an int value between 1 and</span>
<span class="sd">        n/2. </span>
<span class="sd">        TODO: switch default to None once batch_size is implemented.</span>
<span class="sd">        The default is &#39;sqroot&#39;.</span>
<span class="sd">    g : function, optional</span>
<span class="sd">        A function to apply to the samples of the chain. If None,</span>
<span class="sd">        g is set to be the identity, which is the estimation of the mean of</span>
<span class="sd">        the target density. The default is None.</span>
<span class="sd">    adjust : bool, optional</span>
<span class="sd">        Automatically adjust the matrix if it is unstable.</span>
<span class="sd">        The default is True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raised is if r is negative, if size is mis-specified, if b and r both</span>
<span class="sd">        equal 1, or if an unknown method is specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary of the results.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">method_used</span> <span class="o">=</span> <span class="n">method</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;lug&quot;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;bm&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;It&#39;s recommended to use r &lt;= 5. Also, r cannot be &quot;</span>
                      <span class="s2">&quot;negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;r cannot be negative.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">g</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># TODO: include batchSize function as option in the ifelse below (see </span>
    <span class="c1"># mcmcse R docs)</span>
    <span class="c1">#if size is None:</span>
    <span class="c1">#    batchSize(chain=chain, method=method, g=g)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="s2">&quot;sqroot&quot;</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">size</span> <span class="o">==</span> <span class="s2">&quot;cuberoot&quot;</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;size&#39; must be a numeric quantity not &quot;</span>
                             <span class="s2">&quot;larger than n.&quot;</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;r was set to 1 since b = 1.&quot;</span>
    <span class="n">mu_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either decrease r or increase n&quot;</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;bm&quot;</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;obm&quot;</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;bartlett&quot;</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;tukey&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No such method available&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bm&quot;</span><span class="p">:</span>
        <span class="n">bm_mat</span> <span class="o">=</span> <span class="n">mbmc</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">bm_mat</span>
        <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Batch Means&quot;</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sig_mat</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">bm_mat</span> <span class="o">-</span> <span class="n">mbmc</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">r</span><span class="p">))</span>
            <span class="n">method_used</span> <span class="o">&lt;-</span> <span class="s2">&quot;Lugsail Batch Means with r = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sig_mat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">bm_mat</span>
                <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Batch Means&quot;</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Diagonals were negative with r = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;. r = 1 was used.&quot;</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;obm&quot;</span><span class="p">:</span>         
        <span class="n">obm_mat</span> <span class="o">=</span> <span class="n">mobmc</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">obm_mat</span>
        <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Overlapping Batch Means&quot;</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sig_mat</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">obm_mat</span> <span class="o">-</span> <span class="n">mobmc</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">r</span><span class="p">))</span>
            <span class="n">method_used</span> <span class="o">&lt;-</span> <span class="s2">&quot;Lugsail Overlapping Batch Means with r = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sig_mat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">obm_mat</span>
                <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Overlapping Batch Means&quot;</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Diagonals were negative with r = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;. r = 1 was used.&quot;</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bartlett&quot;</span><span class="p">:</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">with_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_std</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">bar_mat</span> <span class="o">=</span> <span class="n">msvec</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot;bartlett&quot;</span><span class="p">)</span>
        <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">bar_mat</span>
        <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Bartlett Spectral Variance&quot;</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sig_mat</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">bar_mat</span> <span class="o">-</span> <span class="n">msvec</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">r</span><span class="p">),</span> <span class="s2">&quot;bartlett&quot;</span><span class="p">)</span>
            <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Lugsail Bartlett Spectral Variance with r = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sig_mat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">bar_mat</span>
                <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Bartlett Spectral Variance&quot;</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Diagonals were negative with r = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;. r = 1 was used.&quot;</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;tukey&quot;</span><span class="p">:</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">with_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_std</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tuk_mat</span> <span class="o">=</span> <span class="n">msvec</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot;tukey&quot;</span><span class="p">)</span>
        <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Tukey Spectral Variance&quot;</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sig_mat</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">tuk_mat</span> <span class="o">-</span> <span class="n">msvec</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">r</span><span class="p">),</span> <span class="s2">&quot;tukey&quot;</span><span class="p">)</span>
            <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Lugsail Tukey Spectral Variance with r = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sig_mat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">tuk_mat</span>
                <span class="n">method_used</span> <span class="o">=</span> <span class="s2">&quot;Tukey Spectral Variance&quot;</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Diagonals were negative with r = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;. r = 1 was used.&quot;</span>
    
    <span class="n">adjust_used</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">adjust</span><span class="p">:</span>
        <span class="n">sig_eigen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">sig_mat</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sig_eigen</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">adjust_used</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">sig_mat</span> <span class="o">=</span> <span class="n">adjust_matrix</span><span class="p">(</span><span class="n">sig_mat</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;cov&#39;</span><span class="p">:</span> <span class="n">sig_mat</span><span class="p">,</span> <span class="s1">&#39;est&#39;</span><span class="p">:</span> <span class="n">mu_hat</span><span class="p">,</span> <span class="s1">&#39;nsim&#39;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
            <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;adjustment_used&#39;</span><span class="p">:</span> <span class="n">adjust_used</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span> <span class="s1">&#39;method_used&#39;</span><span class="p">:</span> <span class="n">method_used</span><span class="p">,</span>
            <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">}</span>


<div class="viewcode-block" id="minESS"><a class="viewcode-back" href="../../generated/tsdst.mcmc.minESS.html#tsdst.mcmc.minESS">[docs]</a><span class="k">def</span> <span class="nf">minESS</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">ess</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translated from the R mcmcse package.</span>
<span class="sd">    </span>
<span class="sd">    Calculates the minimum Effective Sample Size, independent of the MCMC</span>
<span class="sd">    chain for the given number of parameters. `alpha` is the confidence level,</span>
<span class="sd">    `eps` is the tolerance level (ignored when `ess is not None`), and `ess`</span>
<span class="sd">    is the effective sample size. When `ess is not None`, the function returns</span>
<span class="sd">    the tolerance level needed to obtain that ESS.</span>
<span class="sd">    </span>
<span class="sd">    In practice, the user should find the minESS amount and then sample until </span>
<span class="sd">    they hit that number. Usually, it is computationally difficult to obtain</span>
<span class="sd">    the optimal minimum effective sample size, therefore, it is useful to know</span>
<span class="sd">    what tolerance is needed to obtain the samples that can be afforded </span>
<span class="sd">    computationally.</span>

<span class="sd">    see mcmcse::minESS for more information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : int</span>
<span class="sd">        The dimension of the estimation problem (i.e. the number of parameters</span>
<span class="sd">        represented in the MCMC chain, or the number of columns in the MCMC</span>
<span class="sd">        chain).</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        Confidence level. The default is 0.05.</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        Tolerance level. The smaller the tolerance, the larger the minimum </span>
<span class="sd">        effective samples. The default is 0.05.</span>
<span class="sd">    ess : int, optional</span>
<span class="sd">        Estimated effective sample size. The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The minimum effective sample required for a given eps tolerance.</span>
<span class="sd">        If ess is specified, then the value returned is the eps corresponding</span>
<span class="sd">        to that ess.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">crit</span> <span class="o">=</span> <span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">p</span>
    <span class="k">if</span> <span class="n">ess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logminESS</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">loggamma</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">crit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logminESS</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logEPS</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">loggamma</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ess</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">crit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logEPS</span><span class="p">)</span></div>


<div class="viewcode-block" id="multiESS"><a class="viewcode-back" href="../../generated/tsdst.mcmc.multiESS.html#tsdst.mcmc.multiESS">[docs]</a><span class="k">def</span> <span class="nf">multiESS</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">covmat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mcse_multi_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function computes the Effective Sample Size of an MCMC chain. Due to</span>
<span class="sd">    correlation between MCMC samples, it is sometimes unclear how much</span>
<span class="sd">    information about the parameters has been obtained. If all of the MCMC</span>
<span class="sd">    samples were independent, we would need less samples to get accurate</span>
<span class="sd">    information about the posterior than when the samples are correlated.</span>
<span class="sd">    ESS measures the amount of independent samples that have actually been</span>
<span class="sd">    obtained in the MCMC chain, and mESS is a special case for multivariate</span>
<span class="sd">    posteriors. In other words, this method is a way to test if your chain</span>
<span class="sd">    has gone far enough.</span>
<span class="sd">    </span>
<span class="sd">    This information can used in conjunction with minESS, such that the chain</span>
<span class="sd">    has sampled enough when multiESS &gt;= minESS.</span>
<span class="sd">    </span>
<span class="sd">    For more information regarding these functions, see the R documentation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain : numpy array</span>
<span class="sd">        The MCMC chain, where the rows are samples.</span>
<span class="sd">    covmat : numpy array, optional</span>
<span class="sd">        The covaraince matrix for the parameters, if available. If None,</span>
<span class="sd">        matrix is obtained from mcse_multi. The default is None.</span>
<span class="sd">    g : function, optional</span>
<span class="sd">        A function that represents features of</span>
<span class="sd">        interest. `g` is applied to each row of x, and should thus take a</span>
<span class="sd">        vector input only. If g is none, g is set to be identity, which is</span>
<span class="sd">        estimation of the mean of the target density. The default is None.</span>
<span class="sd">        </span>
<span class="sd">        An example of g would be the sum of the second moments of</span>
<span class="sd">        each parameter, i.e.:</span>
<span class="sd">        </span>
<span class="sd">        def g(x):</span>
<span class="sd">            return np.sum(x**2)</span>
<span class="sd">        </span>
<span class="sd">    mcse_multi_args : dict</span>
<span class="sd">        Arguments for mcse_multi function. Don&#39;t use this if a suitable matrix</span>
<span class="sd">        estimate from mcse_multi or mcse_initseq is already obtained. The</span>
<span class="sd">        default is None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ess : int</span>
<span class="sd">        The estimated effective sample size.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mcse_multi_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mcse_multi_args</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">g</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">var_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">covmat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">covmat</span> <span class="o">=</span> <span class="n">mcse_multi</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="o">**</span><span class="n">mcse_multi_args</span><span class="p">)[</span><span class="s1">&#39;cov&#39;</span><span class="p">]</span>
    <span class="n">det_var_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">var_mat</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span>
    <span class="n">det_covmat_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">covmat</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span>
    <span class="n">ess</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">det_var_p</span><span class="o">/</span><span class="n">det_covmat_p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ess</span></div>


<div class="viewcode-block" id="raftery"><a class="viewcode-back" href="../../generated/tsdst.mcmc.raftery.html#tsdst.mcmc.raftery">[docs]</a><span class="k">def</span> <span class="nf">raftery</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">converge_eps</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
             <span class="n">thin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">print_</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Raftery diagnostic to determine how many more samples are</span>
<span class="sd">    needed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain : numpy array</span>
<span class="sd">        MCMC chain.</span>
<span class="sd">    q : float, optional</span>
<span class="sd">        Quantile of interest (in terms of percentile, i.e. between 0 and 1).</span>
<span class="sd">        The default is 0.025.</span>
<span class="sd">    r : float, optional</span>
<span class="sd">        Accuracy. The default is 0.005.</span>
<span class="sd">    s : float, optional</span>
<span class="sd">        Probability. The default is 0.95.</span>
<span class="sd">    converge_eps : float, optional</span>
<span class="sd">        Convergence threshold (epsilon). The default is 0.001.</span>
<span class="sd">    thin : int, optional</span>
<span class="sd">        Thining amount. The default is 1.</span>
<span class="sd">    print_ : bool, optional</span>
<span class="sd">        Print results. The default is False.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raised if there are not enough samples in the chain, given the q,r,s</span>
<span class="sd">        values, or if there is an invalid selection of q.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q must be between 0 and 1&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># forces chain to be shape (:,1) if it is a single parameter chain</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">niter</span><span class="p">,</span> <span class="n">nvar</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Burn-in (M)&quot;</span><span class="p">,</span> <span class="s2">&quot;Total (N)&quot;</span><span class="p">,</span> <span class="s2">&quot;Lower Bound (Nmin)&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;Dependence Factor (I)&quot;</span><span class="p">,</span> <span class="s2">&quot;Thinning (k)&quot;</span><span class="p">]</span>
        <span class="n">resmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nvar</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)))</span>
        <span class="n">resmatrix</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># nmin based on sample size calculation for proportions</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">qnorm_approx</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">s</span><span class="p">))</span>
        <span class="n">nmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nmin</span> <span class="o">&gt;</span> <span class="n">niter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error: You either need to adjust q, r, or &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot; s, or you need a longer chain (at least &quot;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iterations)&quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">Input Parameters: </span><span class="se">\r\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Quantile (q): &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Accuracy (r): +/- &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Probability (s): &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                             <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nvar</span><span class="p">):</span>
                <span class="c1"># U_t = value of the parameter at iteration t</span>
                <span class="c1"># u = value of parameter at defined quantile q</span>
                <span class="n">quant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">chain</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">dichot</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">quant</span>

                <span class="n">kthin</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bic</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">testres</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">newdim</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># To find k ...</span>
                <span class="k">while</span> <span class="n">bic</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">kthin</span> <span class="o">=</span> <span class="n">kthin</span> <span class="o">+</span> <span class="n">thin</span>
                    <span class="c1"># Z_t, the indicator function, or a dichotomous</span>
                    <span class="c1"># variable, representing where U_t &lt;= u</span>
                    <span class="n">testres</span> <span class="o">=</span> <span class="n">dichot</span><span class="p">[::</span><span class="n">kthin</span><span class="p">]</span>
                    <span class="n">newdim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">testres</span><span class="p">)</span>

                    <span class="n">testres</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">testres</span><span class="p">,</span>
                                             <span class="n">categories</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
                    <span class="n">testtran</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">crosstab</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">testres</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">newdim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)],</span>
                                           <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">testres</span><span class="p">[</span><span class="mi">2</span><span class="p">:(</span><span class="n">newdim</span><span class="p">)],</span>
                                           <span class="n">testres</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">newdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]],</span>
                                           <span class="n">margins</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">g2</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># First order MC vs. second order MC test (log</span>
                    <span class="c1"># likelihood ratio statistic, Bishop, Fienberg and</span>
                    <span class="c1"># Holland (1975))</span>
                    <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">testtran</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">][</span><span class="n">i3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">fitted</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">testtran</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">][:]))</span>
                                              <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">testtran</span><span class="p">[:][</span><span class="n">i2</span><span class="p">][</span><span class="n">i3</span><span class="p">])</span>
                                              <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                                     <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">testtran</span><span class="p">[:][</span><span class="n">i2</span><span class="p">][:])</span>
                                                     <span class="p">))</span>
                                    <span class="n">g2</span> <span class="o">=</span> <span class="n">g2</span> <span class="o">+</span> <span class="n">testtran</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">][</span><span class="n">i3</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                                                 <span class="n">testtran</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">][</span><span class="n">i3</span><span class="p">]</span><span class="o">/</span><span class="n">fitted</span>
                                                 <span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span>
                    <span class="n">bic</span> <span class="o">=</span> <span class="n">g2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">newdim</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span>

                <span class="n">finaltran</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">crosstab</span><span class="p">(</span><span class="n">testres</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">newdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span>
                                        <span class="n">testres</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">newdim</span><span class="p">)],</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">finaltran</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">finaltran</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">finaltran</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">finaltran</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">finaltran</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">finaltran</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">tempburn</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">converge_eps</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span><span class="p">))</span>
                            <span class="o">/</span> <span class="nb">max</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">]))</span>
                            <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)))</span>
                            <span class="p">)</span>

                <span class="c1"># M = M * k</span>
                <span class="n">nburn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">tempburn</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">kthin</span><span class="p">)</span>
                <span class="n">tempprec</span> <span class="o">=</span> <span class="p">(((</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span>
                             <span class="n">beta</span> <span class="o">*</span> <span class="n">phi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                            <span class="p">(((</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">nkeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">tempprec</span><span class="p">)</span> <span class="o">*</span> <span class="n">kthin</span>
                <span class="c1"># (M+N) / Nmin, which is the increase in the number of</span>
                <span class="c1"># iterations due to dependence in the sequence.</span>
                <span class="c1"># If I &gt; 1 by a large amount, there is a high level of</span>
                <span class="c1"># dependence (rule of thumb: &gt; 5 indicate problems)</span>
                <span class="c1"># Problems could be due to bad starting values, high</span>
                <span class="c1"># posterior correlations (which are remedied by</span>
                <span class="c1"># transformations that remove correlations), or</span>
                <span class="c1"># &quot;stickiness&quot; in the chain ( could be resolved by changing</span>
                <span class="c1"># MCMC algorithm)</span>
                <span class="n">iratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">nburn</span> <span class="o">+</span> <span class="n">nkeep</span><span class="p">)</span><span class="o">/</span><span class="n">nmin</span>
                <span class="n">resmatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nburn</span>
                <span class="n">resmatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nkeep</span> <span class="o">+</span> <span class="n">nburn</span>
                <span class="n">resmatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nmin</span>
                <span class="n">resmatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">iratio</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">resmatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">kthin</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">resmatrix</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">:</span> <span class="n">q</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">print_</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">Input Parameters: &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Quantile (q): &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;q&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Accuracy (r): +/-&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Probability (s): &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>


<div class="viewcode-block" id="mcmcObject"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.html#tsdst.mcmc.mcmcObject">[docs]</a><span class="k">class</span> <span class="nc">mcmcObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An object to hold MCMC chains, and to store/compute useful metrics on them.</span>
<span class="sd">    Also has some common plotting functionality.</span>
<span class="sd">    </span>
<span class="sd">    To get a chain up and running, run the mcmcWithRaftery method after</span>
<span class="sd">    instantiating the mcmcObject class.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="mcmcObject.__init__"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.__init__.html#tsdst.mcmc.mcmcObject.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;MCMC Object&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for MCMC object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            The name of the object (in case you instantiate multiple objects).</span>
<span class="sd">            The default is &quot;MCMC Object&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chains</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_values</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="mcmcObject.addChain"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.addChain.html#tsdst.mcmc.mcmcObject.addChain">[docs]</a>    <span class="k">def</span> <span class="nf">addChain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newChain</span><span class="p">,</span> <span class="n">chainName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">concat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a chain to your collection of chains.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newChain : numpy array</span>
<span class="sd">            New chain you would like to add to the collection.</span>
<span class="sd">        chainName : str, optional</span>
<span class="sd">            The name of the added chain, used to seperate it from others in the</span>
<span class="sd">            collection. If None, one will be selected for you.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        concat : bool, optional</span>
<span class="sd">            Whether or not to append the new chain to an existing chain.</span>
<span class="sd">            The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chainName</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chainName</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s2">&quot;Chain_&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newChain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">newChain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newChain</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Please convert new chain object to Numpy Array&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">concat</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span> <span class="o">=</span> <span class="n">newChain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">],</span>
                                                         <span class="n">newChain</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">NameError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Failed to concatenate chains. Created new &quot;</span>
                              <span class="s2">&quot;chain instead. Check list of chain keys.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span> <span class="o">=</span> <span class="n">newChain</span></div>

<div class="viewcode-block" id="mcmcObject.removeChain"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.removeChain.html#tsdst.mcmc.mcmcObject.removeChain">[docs]</a>    <span class="k">def</span> <span class="nf">removeChain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">print_</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a chain from the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            Chain to remove.</span>
<span class="sd">        print_ : bool, optional</span>
<span class="sd">            Print a message displaying what was dropped. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">print_</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Chain called &quot;</span> <span class="o">+</span> <span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot; removed&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No chain named &quot;</span><span class="p">,</span> <span class="n">chainName</span><span class="p">)</span></div>

<div class="viewcode-block" id="mcmcObject.showChain"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.showChain.html#tsdst.mcmc.mcmcObject.showChain">[docs]</a>    <span class="k">def</span> <span class="nf">showChain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Display a chain from the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            The name of the chain from the collection to display.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No chain named &quot;</span><span class="p">,</span> <span class="n">chainName</span><span class="p">)</span></div>

<div class="viewcode-block" id="mcmcObject.burnin"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.burnin.html#tsdst.mcmc.mcmcObject.burnin">[docs]</a>    <span class="k">def</span> <span class="nf">burnin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">burninVal</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove values from chain through burnin process (i.e. remove frist</span>
<span class="sd">        burninVal samples)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            The name of the chain from the collection.</span>
<span class="sd">        burninVal : int, optional</span>
<span class="sd">            The number of samples to remove. The default is 3000.</span>
<span class="sd">        replace : bool</span>
<span class="sd">            If True, replace the current chain rather than create a new one</span>
<span class="sd">            without the burnin samples. If a new chain is created, it will</span>
<span class="sd">            be called chainName + &#39;_burnin&#39; + burnunVal, and will be available</span>
<span class="sd">            in the collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">][</span><span class="n">burninVal</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="o">+</span><span class="s1">&#39;_burnin&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">burninVal</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">][</span><span class="n">burninVal</span><span class="p">:,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="mcmcObject.bestRaftery"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.bestRaftery.html#tsdst.mcmc.mcmcObject.bestRaftery">[docs]</a>    <span class="k">def</span> <span class="nf">bestRaftery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.975</span><span class="p">],</span>
                    <span class="n">r</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.90</span><span class="p">,</span> <span class="n">converge_eps</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">print_each</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_final</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run multiple Raftery evaluations and compare. The final raftery output</span>
<span class="sd">        is the maximum value for that criteria obtained from all Raftery</span>
<span class="sd">        evaluations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            The name of the chain from the collection.</span>
<span class="sd">        q : float, optional</span>
<span class="sd">            Quantiles of interest (in terms of percentiles, i.e. between 0 and 1). The default is [0.025, 0.5, 0.975].</span>
<span class="sd">        r : float, optional</span>
<span class="sd">            Accuracy. The default is 0.005.</span>
<span class="sd">        s : float, optional</span>
<span class="sd">            Probability. The default is 0.95.</span>
<span class="sd">        converge_eps : float, optional</span>
<span class="sd">            Convergence threshold (epsilon). The default is 0.001.</span>
<span class="sd">        thin : int, optional</span>
<span class="sd">            Thinning amount. The default is 1.</span>
<span class="sd">        print_each : bool, optional</span>
<span class="sd">            Print results at each evaluation. The default is False.</span>
<span class="sd">        print_final : bool, optional</span>
<span class="sd">            Print the final results. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Burn-in (M)&quot;</span><span class="p">,</span> <span class="s2">&quot;Total (N)&quot;</span><span class="p">,</span> <span class="s2">&quot;Lower Bound (Nmin)&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;Dependence Factor (I)&quot;</span><span class="p">,</span> <span class="s2">&quot;Thinning (k)&quot;</span><span class="p">,</span> <span class="s2">&quot;Quantile&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;Parameter&quot;</span><span class="p">]</span>
        <span class="n">all_samples</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
            <span class="n">needed_size</span> <span class="o">=</span> <span class="n">samp_size_calc_raftery</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">needed_size</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;not enough samples in the chain for quantile &quot;</span> <span class="o">+</span>
                      <span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;. Could not evaluate.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">raftery</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">],</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                              <span class="n">converge_eps</span><span class="o">=</span><span class="n">converge_eps</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span>
                              <span class="n">print_</span><span class="o">=</span><span class="n">print_each</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;Quantile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">res</span><span class="p">[</span><span class="s1">&#39;Parameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">index</span>
                <span class="n">all_samples</span> <span class="o">=</span> <span class="n">all_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">maxcols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Max Burn-in (M)&quot;</span><span class="p">,</span> <span class="s2">&quot;Max Total (N)&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;Max Lower Bound (Nmin)&quot;</span><span class="p">,</span> <span class="s2">&quot;Max Dependence Factor (I)&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;Max Thinning (k)&quot;</span><span class="p">]</span>
        <span class="n">maxvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_samples</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">finalres</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">maxvals</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                                <span class="n">columns</span><span class="o">=</span><span class="n">maxcols</span><span class="p">)</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">:</span> <span class="n">q</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">print_final</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">Input Parameters: &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Quantile (q): &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;q&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Accuracy (r): +/-&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Probability (s): &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">finalres</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_Raftery&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">finalres</span></div>

<div class="viewcode-block" id="mcmcObject.tj_convergence_test"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.tj_convergence_test.html#tsdst.mcmc.mcmcObject.tj_convergence_test">[docs]</a>    <span class="k">def</span> <span class="nf">tj_convergence_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">quantiles</span><span class="o">=</span><span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">],</span>
                            <span class="n">window_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_windows</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">slide</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                            <span class="n">window_space</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bin_limit</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">print_final</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A test to evaluate convergence. </span>
<span class="sd">        </span>
<span class="sd">        This test evaluates a moving window, or a list of moving windows and</span>
<span class="sd">        compares the values of the distribution tails in those windows. If the</span>
<span class="sd">        distribution tails of all the moving windows is in line with the</span>
<span class="sd">        distribution tails of the final n samples of the chain, then the chain</span>
<span class="sd">        is considered to have converged.</span>
<span class="sd">        </span>
<span class="sd">        This is a homemade convergence test for MCMC chains developed by Tom</span>
<span class="sd">        Werner and Joel Linford (TJ). While these ideas were novel to them at</span>
<span class="sd">        the time of discovery, it has since been revealed that their methods are</span>
<span class="sd">        related or similar to diagnostics proposed by more noteworthy</span>
<span class="sd">        statisticians, such as Heidelberger and Welch or Gewke. Still, this</span>
<span class="sd">        method has proven to perform well when compared with more</span>
<span class="sd">        well-known methods.</span>

<span class="sd">        This method uses moving windows (default is 5) to slide across the</span>
<span class="sd">        chain (starting from the beginning) and measure the given quantiles of</span>
<span class="sd">        the chain in each window (for example, the top 5% or the lower 5%), and</span>
<span class="sd">        compare that with the equivalent quantile values at the end of the</span>
<span class="sd">        chain. If all 5 windows are within some percent difference (eps,</span>
<span class="sd">        percent expressed in decimals) of the ending quantiles, then the</span>
<span class="sd">        chain is assumed to have reached a stationary distribution. bin_limit</span>
<span class="sd">        is defined as the percentage of the chain (starting from the beginning)</span>
<span class="sd">        that the windows are allowed to pass through. If any of the windows pass</span>
<span class="sd">        by the bin_limt, then the chain is said to have not reached</span>
<span class="sd">        stationarity.</span>
<span class="sd">        </span>
<span class="sd">        If window_size=None, then the window size is determined to be 5% of the</span>
<span class="sd">        total numbers of rows. slide is how much the windows move down the chain</span>
<span class="sd">        after each iteration, and window_space is the amount of space between</span>
<span class="sd">        windows. eps is the tolerance of the percent difference. quantiles</span>
<span class="sd">        should be a list of decimals representing the quantiles of interest.</span>
<span class="sd">        </span>
<span class="sd">        This method requires some assumptions:</span>

<span class="sd">            1. That the chain has been run long enough to have already reached \</span>
<span class="sd">               stationarity of the target distribution, not stationarity of an \</span>
<span class="sd">               arbitrary distribution</span>
<span class="sd">                - For example, this could be used after the Raftery diagnostic \</span>
<span class="sd">                  or after obtaining a sufficient number of Effective samples</span>
<span class="sd">            2. That the burn-in value is being interpreted as the closest points \</span>
<span class="sd">               in the chain to which stationarity occurs, and that the maximum \</span>
<span class="sd">               value between parameters is chosen for the burn-in value</span>
<span class="sd">            3. That both parameters must pass for the burn-in value to be valid \</span>
<span class="sd">               and for the chain to be considered reaching stationarity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            The name of the chain from the collection.</span>
<span class="sd">        eps : float, optional</span>
<span class="sd">            The threshold for comparing similarity in the chain. If the</span>
<span class="sd">            similarity between the moving window distributions and the</span>
<span class="sd">            distribution at the end of the chain is below the threshold, then</span>
<span class="sd">            the chain is considered to have converged. The default is 0.025.</span>
<span class="sd">        quantiles : list, or list-like, optional</span>
<span class="sd">            The sections of the distributions to consider for similarity.</span>
<span class="sd">            The default is [0.05, 0.95].</span>
<span class="sd">        window_size : int, optional</span>
<span class="sd">            How many chain samples to consider in each window. If None,</span>
<span class="sd">            it is automatically determined based on the size of the chain.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        num_windows : int, optional</span>
<span class="sd">            The number of moving windows to use in the evaluation.</span>
<span class="sd">            The default is 5.</span>
<span class="sd">        slide : int, optional</span>
<span class="sd">            The number of samples to slide after each iteration, or in other </span>
<span class="sd">            words, how fast the moving windows move (a larger value for slide</span>
<span class="sd">            means less total evaluations). The default is 50.</span>
<span class="sd">        window_space : int, optional</span>
<span class="sd">            The distance between each window. If positive, there is a gap. If</span>
<span class="sd">            negative, there is overlap. The default is 0.</span>
<span class="sd">        bin_limit : float, optional</span>
<span class="sd">            The bin_limit is the percent (between 0 and 1) of samples</span>
<span class="sd">            that are used in the moving windows, or in other words, the </span>
<span class="sd">            evaluation stops once the right edge (i.e. most recently sampled </span>
<span class="sd">            observation in the chain) matches the upper limit determined by</span>
<span class="sd">            the bin_limit percent. Also, 1 - bin_limit is the amount of samples</span>
<span class="sd">            from the end that are used as a baseline to see if the chain has</span>
<span class="sd">            converged. The default is 0.6.</span>
<span class="sd">        print_final : bool, optional</span>
<span class="sd">            Print the final results. The default is False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raises ValueError if argumnets passed by the user are outside</span>
<span class="sd">            function constraints.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">])</span>
        <span class="c1"># eps must be greater than 0</span>
        <span class="c1"># window size needs to be a number between 1 and</span>
        <span class="c1"># bin_limit of the length of the chain</span>
        <span class="c1"># bin_limit must be between 0 and 1</span>
        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">bin_limit</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">float</span><span class="p">(</span><span class="n">bin_limit</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bin_limit must be between 0 and 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eps must be greater than 0 (its good to pick a &quot;</span>
                             <span class="s2">&quot;decimal close to zero, but not equal to it)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num_windows</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_windows must be greater than 0&quot;</span><span class="p">)</span>

        <span class="n">nrows</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">window_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.05</span><span class="o">*</span><span class="n">nrows</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">float</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">float</span><span class="p">(</span><span class="n">slide</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;window_size or slide must be at least 1&quot;</span><span class="p">)</span>

        <span class="n">max_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nrows</span> <span class="o">*</span> <span class="n">bin_limit</span><span class="p">)</span>
        <span class="n">init_right_edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">num_windows</span><span class="p">)</span> <span class="o">+</span> \
                          <span class="p">(</span><span class="n">window_space</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_windows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">max_row</span> <span class="o">-</span> <span class="n">init_right_edge</span><span class="p">)</span> <span class="o">/</span> <span class="n">slide</span><span class="p">)</span>

        <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Burn-in&quot;</span><span class="p">,</span> <span class="s2">&quot;Ending Bin&quot;</span><span class="p">,</span> <span class="s2">&quot;Total Bins&quot;</span><span class="p">,</span> <span class="s2">&quot;Status&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;Notes&quot;</span><span class="p">,</span> <span class="s2">&quot;Msg Details&quot;</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">col_names</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">):</span>
            <span class="n">cur_chain</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span>
            <span class="n">end_cur_chain</span> <span class="o">=</span> <span class="n">cur_chain</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">max_row</span><span class="p">):]</span>
            <span class="n">quantiles</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">end_per</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">end_cur_chain</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quantiles</span><span class="p">))</span>
            <span class="n">bin_i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">per_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_windows</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)))</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span>
            <span class="n">bin_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_windows</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">num_windows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">index_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index_vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_mat</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bin_mat</span> <span class="o">*</span> <span class="n">window_space</span><span class="p">)</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">per_ratios</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">eps</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">bin_i</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_vals</span><span class="p">)):</span>
                    <span class="n">window_chain</span> <span class="o">=</span> <span class="n">cur_chain</span><span class="p">[</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">index_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">index_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">window_size</span><span class="p">)]</span>
                    <span class="n">per_ratios</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
                            <span class="n">window_chain</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quantiles</span><span class="p">))</span> <span class="o">/</span> <span class="n">end_per</span>

                <span class="n">index_vals</span> <span class="o">+=</span> <span class="n">slide</span>
                <span class="n">bin_i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">bin_i</span> <span class="o">&gt;</span> <span class="n">bins</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unsuccessful&quot;</span>
                <span class="n">sub_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Fully iterated before meeting criteria, may not &quot;</span>
                           <span class="s2">&quot;have stabilized on a distribution. Try adjusting the settings &quot;</span>
                           <span class="s2">&quot;and try again, or take a look at the plot&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">per_ratios</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">eps</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unsuccessful&quot;</span>
                <span class="n">sub_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Did not appear to stabilize on a distribution. &quot;</span>
                           <span class="s2">&quot;Try adjusting the settings and try again, or take a &quot;</span>
                           <span class="s2">&quot;look at the plot&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Successful&quot;</span>
                <span class="n">sub_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">msg_display</span> <span class="o">=</span> <span class="s2">&quot;See Msg Details in DataFrame&quot;</span>

            <span class="k">if</span> <span class="n">num_windows</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">burnin</span> <span class="o">=</span> <span class="n">index_vals</span><span class="p">[</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">bin_mat</span><span class="p">))]</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">window_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">burnin</span> <span class="o">=</span> <span class="n">index_vals</span><span class="p">[</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">bin_mat</span><span class="p">)))]</span> <span class="o">+</span> <span class="n">window_size</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="n">burnin</span><span class="p">,</span> <span class="n">bin_i</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
                                            <span class="n">msg_display</span><span class="p">,</span> <span class="n">sub_msg</span><span class="p">]],</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="n">col_names</span><span class="p">),</span>
                             <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;eps&quot;</span><span class="p">:</span> <span class="n">eps</span><span class="p">,</span> <span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="n">window_size</span><span class="p">,</span>
                  <span class="s2">&quot;num_windows&quot;</span><span class="p">:</span> <span class="n">num_windows</span><span class="p">,</span> <span class="s2">&quot;slide&quot;</span><span class="p">:</span> <span class="n">slide</span><span class="p">,</span>
                  <span class="s2">&quot;window_space&quot;</span><span class="p">:</span> <span class="n">window_space</span><span class="p">,</span> <span class="s2">&quot;bin_limit&quot;</span><span class="p">:</span> <span class="n">bin_limit</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">print_final</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">Input Parameters: &quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Ratio Epsilon: &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;eps&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Window Size: &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;window_size&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Number of Windows: &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;num_windows&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Slide Amount: &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;slide&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Space between Windows: &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;window_space&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Bin Limit Percentage: &quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;bin_limit&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">res</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="s2">&quot;Msg Details&quot;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_Convtest&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span></div>

<div class="viewcode-block" id="mcmcObject.runMCMC"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.runMCMC.html#tsdst.mcmc.mcmcObject.runMCMC">[docs]</a>    <span class="k">def</span> <span class="nf">runMCMC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">initSampleSize</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">algo</span><span class="p">,</span> <span class="n">algoOpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">raftOpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chainName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_tries</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
                <span class="n">plot_trace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_acf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">plot_trace_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_density_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">plot_acf_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">acfType</span><span class="o">=</span><span class="s1">&#39;pacf&#39;</span><span class="p">,</span> <span class="n">acf_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">do_raftery</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">750000</span><span class="p">,</span> <span class="n">burnin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">lpost_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate MCMC samples and evaluate samples size (using Raftery)</span>
<span class="sd">        and convergence.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : numpy array</span>
<span class="sd">            Starting values for the MCMC.</span>
<span class="sd">        initSampleSize : int</span>
<span class="sd">            The number of MCMC samples to draw on the first run. It&#39;s good to start relatively small, because the</span>
<span class="sd">            Raftery evaluation will tell you how many more samples need to be drawn.</span>
<span class="sd">        lpost : function</span>
<span class="sd">            Log posterior function.</span>
<span class="sd">        algo : function</span>
<span class="sd">            The MCMC algorithm to use (could be anything, but needs to have the same arguments as inputs for the</span>
<span class="sd">            algorithms already defined, namely:</span>

<span class="sd">                start : numpy array</span>
<span class="sd">                    Starting values for the MCMC.</span>
<span class="sd">                niter : int</span>
<span class="sd">                    Number of iterations.</span>
<span class="sd">                lpost : function</span>
<span class="sd">                    Log posterior function.</span>
<span class="sd">                postArgs : dict</span>
<span class="sd">                    Extra arguments for the log posterior function. The default is None</span>
<span class="sd">                options : dict, optional</span>
<span class="sd">                    Extra arguments for the specific MCMC algorithm</span>
<span class="sd">        algoOpts : dict, optional</span>
<span class="sd">            Extra arguments for the specific MCMC algorithm. The default is None.</span>
<span class="sd">        raftOpts : dict, optional</span>
<span class="sd">            A dictionary containing the options for the Raftery evaluation. The default is None. Options include:</span>

<span class="sd">                q : float, optional</span>
<span class="sd">                    Quantiles of interest (in terms of percentiles, i.e. between 0 and 1). The default is [0.025, 0.5, 0.975].</span>
<span class="sd">                r : float, optional</span>
<span class="sd">                    Accuracy. The default is 0.005.</span>
<span class="sd">                s : float, optional</span>
<span class="sd">                    Probability. The default is 0.95.</span>
<span class="sd">                converge_eps : float, optional</span>
<span class="sd">                    Convergence threshold (epsilon). The default is 0.001.</span>
<span class="sd">                thin : int, optional</span>
<span class="sd">                    Thining amount. The default is 1.</span>
<span class="sd">                print_each : bool, optional</span>
<span class="sd">                    Print results at each evaluation. The default is False.</span>
<span class="sd">                print_final : bool, optional</span>
<span class="sd">                    Print the final results. The default is False.</span>
<span class="sd">        chainName : str, optional</span>
<span class="sd">            The name of the chain that will be created. If None,</span>
<span class="sd">            &#39;`Chain_`&#39; + int (for number of chains in the collection)</span>
<span class="sd">            will be used. The default is None.</span>
<span class="sd">        max_tries : int, optional</span>
<span class="sd">            The max number of times to try and jitter before admitting defeat. If the jitter fails, the reason for the</span>
<span class="sd">            covariance matrix not being positive definite may not be due to randomness, and may require</span>
<span class="sd">            a re-evaluation of the problem space. The default is 100.</span>
<span class="sd">        sd : float, optional</span>
<span class="sd">            The standard deviation of the normal distribution used to draw the</span>
<span class="sd">            jitter amount from. In other words, the jittered covariance is the </span>
<span class="sd">            covariance matrix plus a random draw X, where X~N(0, sd).</span>
<span class="sd">            The default is 0.02.</span>
<span class="sd">        plot_trace : bool, optional</span>
<span class="sd">            Plot the trace of the MCMC samples. The default is True.</span>
<span class="sd">        plot_density : bool, optional</span>
<span class="sd">            Plot the posterior density of the MCMC samples.</span>
<span class="sd">            The default is True.</span>
<span class="sd">        plot_acf : bool, optional</span>
<span class="sd">            Plot the auto-correlation. The default is True.</span>
<span class="sd">        plot_trace_args : dict</span>
<span class="sd">            Arguments for the plotTrace function. Default is None.</span>
<span class="sd">        plot_density_args : dict</span>
<span class="sd">            Arguments for the plotDensity function. Default is None.</span>
<span class="sd">        plot_acf_args : dict</span>
<span class="sd">            Arguments for the plotACF function. Default is None.</span>
<span class="sd">        acf_type : str</span>
<span class="sd">            Ether &#39;acf&#39;, &#39;pacf&#39;, or None. Default is &#39;pacf&#39;. If None, pacf</span>
<span class="sd">            calculation is not performed.</span>
<span class="sd">        acf_args : dict</span>
<span class="sd">            Arguments to pass to the `acf` function. Default is None.</span>
<span class="sd">        do_raftery : bool, optional</span>
<span class="sd">            Whether to perform the raftery evaluation, or stop after the</span>
<span class="sd">            first chain generation. Default is True.</span>
<span class="sd">        max_iters : int, optional</span>
<span class="sd">            The max number of new samples to draw. For example, if the Raftery</span>
<span class="sd">            evaluation recommends 1 million new samples, and max_iters is </span>
<span class="sd">            750000, then the new samples will be restricted at 750000.</span>
<span class="sd">            The default is 750000.</span>
<span class="sd">        burnin : int, optional</span>
<span class="sd">            The number of initial MCMC samples to drop from the chain.</span>
<span class="sd">            If burnin is negative or zero, the burnin amount will be determined</span>
<span class="sd">            automatically. If positive, it will drop that amount. If </span>
<span class="sd">            None, it will do nothing. The default is 0.</span>
<span class="sd">        lpost_args : dict, optional</span>
<span class="sd">            Any extra arguments to pass to the log posterior function.</span>
<span class="sd">            The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: Update to include ESS option, instead of just raftery.</span>
        <span class="k">if</span> <span class="n">algoOpts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">algoOpts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">first_run_results</span> <span class="o">=</span> <span class="n">applyMCMC</span><span class="p">(</span><span class="n">st</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">ni</span><span class="o">=</span><span class="n">initSampleSize</span><span class="p">,</span> <span class="n">lp</span><span class="o">=</span><span class="n">lpost</span><span class="p">,</span>
                                      <span class="n">algo</span><span class="o">=</span><span class="n">algo</span><span class="p">,</span> <span class="n">algoOpts</span><span class="o">=</span><span class="n">algoOpts</span><span class="p">,</span>
                                      <span class="n">postArgs</span><span class="o">=</span><span class="n">lpost_args</span><span class="p">,</span>
                                      <span class="n">sd</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">max_tries</span><span class="o">=</span><span class="n">max_tries</span><span class="p">)</span>
        <span class="c1"># TODO: change this so it&#39;s not hardcoded</span>
        <span class="n">previous_values</span> <span class="o">=</span> <span class="n">first_run_results</span><span class="p">[</span><span class="s1">&#39;prev_vals&#39;</span><span class="p">]</span>
        <span class="n">new_start</span> <span class="o">=</span> <span class="n">first_run_results</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">addChain</span><span class="p">(</span><span class="n">first_run_results</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">],</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">concat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_values</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_latestrun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous_values</span>

        <span class="k">if</span> <span class="n">do_raftery</span><span class="p">:</span>
            <span class="n">qq</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.975</span><span class="p">]</span>
            <span class="n">rr</span> <span class="o">=</span> <span class="mf">0.005</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="mf">0.90</span>
            <span class="n">ce</span> <span class="o">=</span> <span class="mf">0.001</span>
            <span class="n">th</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">pe</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">pf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">raftOpts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">raftOpts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">if</span> <span class="s1">&#39;q&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">qq</span> <span class="o">=</span> <span class="n">raftOpts</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;r&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">rr</span> <span class="o">=</span> <span class="n">raftOpts</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">ss</span> <span class="o">=</span> <span class="n">raftOpts</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;converge_eps&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">ce</span> <span class="o">=</span> <span class="n">raftOpts</span><span class="p">[</span><span class="s1">&#39;converge_eps&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;thin&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">th</span> <span class="o">=</span> <span class="n">raftOpts</span><span class="p">[</span><span class="s1">&#39;thin&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;print_each&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">pe</span> <span class="o">=</span> <span class="n">raftOpts</span><span class="p">[</span><span class="s1">&#39;print_each&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;print_final&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">pf</span> <span class="o">=</span> <span class="n">raftOpts</span><span class="p">[</span><span class="s1">&#39;print_final&#39;</span><span class="p">]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">bestRaftery</span><span class="p">(</span><span class="n">chainName</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">qq</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">rr</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">ss</span><span class="p">,</span> <span class="n">converge_eps</span><span class="o">=</span><span class="n">ce</span><span class="p">,</span>
                             <span class="n">thin</span><span class="o">=</span><span class="n">th</span><span class="p">,</span> <span class="n">print_each</span><span class="o">=</span><span class="n">pe</span><span class="p">,</span> <span class="n">print_final</span><span class="o">=</span><span class="n">pf</span><span class="p">)</span>
            <span class="n">raftmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_Raftery&quot;</span><span class="p">][</span><span class="s2">&quot;Max Total (N)&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">initial_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">iters_to_go</span> <span class="o">=</span> <span class="n">raftmin</span> <span class="o">-</span> <span class="n">initial_len</span>
            
            <span class="k">if</span> <span class="n">iters_to_go</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iters_to_go</span> <span class="o">&gt;=</span> <span class="n">max_iters</span><span class="p">:</span>
                    <span class="n">iters_to_go</span> <span class="o">=</span> <span class="n">max_iters</span>
                <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_values</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_latestrun&quot;</span><span class="p">]</span>
                <span class="n">algoOpts</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;prev_vals&#39;</span><span class="p">:</span> <span class="n">pv</span><span class="p">})</span>
                <span class="n">final_run_results</span> <span class="o">=</span> <span class="n">applyMCMC</span><span class="p">(</span><span class="n">st</span><span class="o">=</span><span class="n">new_start</span><span class="p">,</span>
                                              <span class="n">ni</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">iters_to_go</span><span class="p">),</span>
                                              <span class="n">lp</span><span class="o">=</span><span class="n">lpost</span><span class="p">,</span>
                                              <span class="n">algo</span><span class="o">=</span><span class="n">algo</span><span class="p">,</span>
                                              <span class="n">algoOpts</span><span class="o">=</span><span class="n">algoOpts</span><span class="p">,</span>
                                              <span class="n">postArgs</span><span class="o">=</span><span class="n">lpost_args</span><span class="p">,</span>
                                              <span class="n">sd</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span>
                                              <span class="n">max_tries</span><span class="o">=</span><span class="n">max_tries</span><span class="p">)</span>
                <span class="n">previous_values</span> <span class="o">=</span> <span class="n">final_run_results</span><span class="p">[</span><span class="s1">&#39;prev_vals&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addChain</span><span class="p">(</span><span class="n">final_run_results</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">],</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">concat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">previous_values</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_latestrun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous_values</span>

        <span class="n">burnin_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">burnVal</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">burnin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">burnin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tj_convergence_test</span><span class="p">(</span><span class="n">chainName</span><span class="p">)</span>
                <span class="n">conv_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_Convtest&quot;</span><span class="p">]</span>
                <span class="c1"># burnin_param gets used in plotting later. It&#39;s possible for each</span>
                <span class="c1"># parameter to have a separate optimal burn-in point, however,</span>
                <span class="c1"># the parameters themselves should not be considered </span>
                <span class="c1"># independently, and thus, need a common burn-in value</span>
                <span class="n">burnin_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">conv_diag</span><span class="p">[</span><span class="s2">&quot;Burn-in&quot;</span><span class="p">])</span>
                <span class="n">burnVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">conv_diag</span><span class="p">[</span><span class="s2">&quot;Burn-in&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># burnin_param is for plotting purposes only</span>
                <span class="n">burnin_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">burnin</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
                <span class="n">burnVal</span> <span class="o">=</span> <span class="n">burnin</span>

        <span class="k">if</span> <span class="n">plot_trace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plot_trace_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plot_trace_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;CTres&#39;</span><span class="p">:</span> <span class="n">burnin_param</span><span class="p">,</span>
                                   <span class="s1">&#39;write&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="s1">&#39;pdir&#39;</span><span class="p">:</span> <span class="s2">&quot;./Plots/&quot;</span><span class="p">,</span>
                                   <span class="s1">&#39;fileType&#39;</span><span class="p">:</span> <span class="s2">&quot;png&quot;</span><span class="p">,</span>
                                   <span class="s1">&#39;figsize&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
                                   <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_trace_args</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;CTres&#39;</span><span class="p">:</span> <span class="n">burnin_param</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotTrace</span><span class="p">(</span><span class="n">chainName</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_trace_args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_density</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plot_density_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plot_density_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;smoothing&#39;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span>
                                     <span class="s1">&#39;write&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                                     <span class="s1">&#39;pdir&#39;</span><span class="p">:</span> <span class="s2">&quot;./Plots/&quot;</span><span class="p">,</span>
                                     <span class="s1">&#39;vlines&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="s1">&#39;fileType&#39;</span><span class="p">:</span> <span class="s2">&quot;png&quot;</span><span class="p">,</span>
                                     <span class="s1">&#39;figsize&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
                                     <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotDensity</span><span class="p">(</span><span class="n">chainName</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_density_args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">acfType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">acfType</span> <span class="o">==</span> <span class="s1">&#39;pacf&#39;</span><span class="p">:</span>
                <span class="n">partial</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">partial</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="k">if</span> <span class="n">acf_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">acf_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lag&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
                            <span class="s1">&#39;partial&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">,</span>
                            <span class="s1">&#39;demean&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acf_args</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;partial&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">})</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">acf</span><span class="p">(</span><span class="n">chainName</span><span class="p">,</span> <span class="o">**</span><span class="n">acf_args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot_acf</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">plot_acf_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plot_acf_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bounds&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                                     <span class="s1">&#39;ci&#39;</span><span class="p">:</span> <span class="mf">0.95</span><span class="p">,</span>
                                     <span class="s1">&#39;acfType&#39;</span><span class="p">:</span> <span class="n">acfType</span><span class="p">,</span>
                                     <span class="s1">&#39;write&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                                     <span class="s1">&#39;pdir&#39;</span><span class="p">:</span> <span class="s2">&quot;./Plots/&quot;</span><span class="p">,</span>
                                     <span class="s1">&#39;fileType&#39;</span><span class="p">:</span> <span class="s2">&quot;png&quot;</span><span class="p">,</span>
                                     <span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="s1">&#39;figsize&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
                                     <span class="p">}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plotACF</span><span class="p">(</span><span class="n">chainName</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_acf_args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">burnin</span><span class="p">(</span><span class="n">chainName</span><span class="p">,</span> <span class="n">burnVal</span><span class="p">)</span></div>

<div class="viewcode-block" id="mcmcObject.plotTrace"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.plotTrace.html#tsdst.mcmc.mcmcObject.plotTrace">[docs]</a>    <span class="k">def</span> <span class="nf">plotTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">CTres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">display</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pdir</span><span class="o">=</span><span class="s2">&quot;./Plots/&quot;</span><span class="p">,</span>
                  <span class="n">fileType</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Plot the trace of the MCMC chain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            The name of the MCMC chain.</span>
<span class="sd">        CTres : numpy array, optional</span>
<span class="sd">            The results of the tj_convergence_test. The default is None.</span>
<span class="sd">        write : bool, optional</span>
<span class="sd">            Write plot to a directory. The default is False.</span>
<span class="sd">        display : bool, optional</span>
<span class="sd">            Display the plot.</span>
<span class="sd">        pdir : str, optional</span>
<span class="sd">            The directory to write the plots to. The default is &quot;./Plots/&quot;.</span>
<span class="sd">        fileType : str, optional</span>
<span class="sd">            The filetype of the image. The default is &quot;png&quot;.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            The figure size (see matplotlib documentation for more details).</span>
<span class="sd">            The default is (15, 12).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig, ax : tuple</span>
<span class="sd">            The figure and axes components of the plot.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nparam</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="n">nparam</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                               <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nparam</span><span class="p">):</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">trace</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Sample Values&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;Value for Parameter &quot;</span><span class="p">,</span>
                                         <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span>
                                         <span class="nb">str</span><span class="p">(</span><span class="n">nparam</span><span class="p">),</span> <span class="s2">&quot; Value&quot;</span><span class="p">]))</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Iteration (Sample) Number&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Trace Plot for &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                                   <span class="s2">&quot; Parameters&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">CTres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">CTres</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                 <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Recommended Burnin&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">write</span><span class="p">:</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">pdir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">pdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span>
                                 <span class="s2">&quot;_trace.&quot;</span><span class="p">,</span> <span class="n">fileType</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="c1">#plt.close()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="mcmcObject.plotDensity"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.plotDensity.html#tsdst.mcmc.mcmcObject.plotDensity">[docs]</a>    <span class="k">def</span> <span class="nf">plotDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">display</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pdir</span><span class="o">=</span><span class="s2">&quot;./Plots/&quot;</span><span class="p">,</span> <span class="n">vlines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">fileType</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Plot the density of the MCMC chain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            The name of the MCMC chain.</span>
<span class="sd">        smoothing : float, optional</span>
<span class="sd">            The amount of smoothing to use on the kde plot.</span>
<span class="sd">            See seaborn.kde_plot for details.</span>
<span class="sd">            The default is 0.05.</span>
<span class="sd">        write : bool, optional</span>
<span class="sd">            Write plot to a directory. The default is False.</span>
<span class="sd">        display : bool, optional</span>
<span class="sd">            Display the plot.</span>
<span class="sd">        pdir : str, optional</span>
<span class="sd">            The directory to write the plots to. The default is &quot;./Plots/&quot;.</span>
<span class="sd">        vlines : TYPE, optional</span>
<span class="sd">            The x-axis locations of any predetermined vertical lines on the</span>
<span class="sd">            density plots, such as mean, median, or mode.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        fileType : str, optional</span>
<span class="sd">            The filetype of the image. The default is &quot;png&quot;.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            The figure size (see matplotlib documentation for more details).</span>
<span class="sd">            The default is (15, 12).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig, ax : tuple</span>
<span class="sd">            The figure and axes components of the plot.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nparam</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">nparam</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                               <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nparam</span><span class="p">):</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span><span class="n">trace</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">shade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Density&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;Value for Parameter &quot;</span><span class="p">,</span> 
                                         <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">nparam</span><span class="p">)]))</span>
            <span class="k">if</span> <span class="n">vlines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">vlines</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Posterior Density of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; Parameters&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">write</span><span class="p">:</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">pdir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">pdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="s2">&quot;_density.&quot;</span><span class="p">,</span>
                                 <span class="n">fileType</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="c1">#plt.close()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="mcmcObject.plotACF"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.plotACF.html#tsdst.mcmc.mcmcObject.plotACF">[docs]</a>    <span class="k">def</span> <span class="nf">plotACF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ci</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">acfType</span><span class="o">=</span><span class="s2">&quot;acf&quot;</span><span class="p">,</span>
                <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pdir</span><span class="o">=</span><span class="s2">&quot;./Plots/&quot;</span><span class="p">,</span> <span class="n">fileType</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">,</span>
                <span class="n">lw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Plot the Autocorrelation function of the chain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            The name of the MCMC chain.</span>
<span class="sd">        bounds : bool, optional</span>
<span class="sd">            Draw the bounds of the autocorrelation. The default is True.</span>
<span class="sd">        ci : float, optional</span>
<span class="sd">            The size of the bounds (confidence interval), if applicable.</span>
<span class="sd">            The default is 0.95.</span>
<span class="sd">        acfType : str, optional</span>
<span class="sd">            The type of acf plot to draw. Can be either &#39;acf&#39; or &#39;pacf&#39;.</span>
<span class="sd">            The default is &quot;acf&quot;.</span>
<span class="sd">        write : bool, optional</span>
<span class="sd">            Write plot to a directory. The default is False.</span>
<span class="sd">        display : bool, optional</span>
<span class="sd">            Display the plot.</span>
<span class="sd">        pdir : str, optional</span>
<span class="sd">            The directory to write the plots to. The default is &quot;./Plots/&quot;.</span>
<span class="sd">        fileType : str, optional</span>
<span class="sd">            The filetype of the image. The default is &quot;png&quot;.</span>
<span class="sd">        lw : float, optional</span>
<span class="sd">            The line width to use on the plot. If None, it will be calculated</span>
<span class="sd">            automatically. The default is None.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            The figure size (see matplotlib documentation for more details).</span>
<span class="sd">            The default is (15, 12).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig, ax : tuple</span>
<span class="sd">            The figure and axes components of the plot.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">acfType</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No ACF found. Please calculate ACF, pACF, or &quot;</span>
                  <span class="s2">&quot;a variant using available methods&quot;</span><span class="p">)</span>
        <span class="n">allacf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">acfType</span><span class="p">]</span>
        <span class="n">allacf</span> <span class="o">=</span> <span class="n">allacf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">allacf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">nparam</span><span class="p">)</span> <span class="o">=</span> <span class="n">allacf</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="n">nparam</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                               <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Picked this as the line width value because it seems to pick a good</span>
        <span class="c1"># width with respect to the lag number. the plot is designed to mimic</span>
        <span class="c1"># the R acf() function</span>
        <span class="k">if</span> <span class="n">lw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.00346103</span><span class="o">*</span><span class="p">(</span><span class="n">samples</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nparam</span><span class="p">):</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">allacf</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])),</span> <span class="n">allacf</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="n">lw</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">acfType</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s2">&quot; for Param. &quot;</span><span class="p">,</span>
                                         <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">nparam</span><span class="p">)]))</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;ACF Plot for &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                                   <span class="s2">&quot; Parameters&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nparam</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Lag&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="p">:</span>
                <span class="n">bnd</span> <span class="o">=</span> <span class="n">qnorm_approx</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">ci</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">bnd</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                 <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=-</span><span class="n">bnd</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                 <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">write</span><span class="p">:</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">pdir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">pdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">acfType</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">fileType</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="c1">#plt.close()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="mcmcObject.acf"><a class="viewcode-back" href="../../generated/tsdst.mcmc.mcmcObject.acf.html#tsdst.mcmc.mcmcObject.acf">[docs]</a>    <span class="k">def</span> <span class="nf">acf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainName</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">demean</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ACF definition for a wide-sense stationary process, partial acf uses</span>
<span class="sd">        Yule-Walker MLE method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chainName : str</span>
<span class="sd">            The name of the MCMC chain.</span>
<span class="sd">        lag : int, optional</span>
<span class="sd">            The lag in the autocorrelation. The default is 50.</span>
<span class="sd">        partial : bool, optional</span>
<span class="sd">            Calculate pACF instead of ACF. The default is False.</span>
<span class="sd">        demean : bool, optional</span>
<span class="sd">            Center the chain before calculating autocorrelation.</span>
<span class="sd">            The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">chainName</span><span class="p">]</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">allacf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[:,</span> <span class="n">param</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">demean</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">acf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">center</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">samples</span> <span class="c1">## variance of x</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">lag</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">partial</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">headlag</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="n">k</span><span class="p">:]</span>
                        <span class="n">taillag</span> <span class="o">=</span> <span class="n">center</span><span class="p">[:</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">headlag</span><span class="o">*</span><span class="n">taillag</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">samples</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">headlag</span><span class="o">*</span><span class="n">taillag</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">samples</span><span class="o">-</span><span class="n">l</span><span class="p">)</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">rho</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="c1">#sigma2 = r[0] - (r[1:]*rho).sum()</span>
                    <span class="n">acf</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">headlag</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="n">l</span><span class="p">:]</span>
                    <span class="n">taillag</span> <span class="o">=</span> <span class="n">center</span><span class="p">[:</span><span class="o">-</span><span class="n">l</span><span class="p">]</span>
                    <span class="n">acf</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">headlag</span><span class="o">*</span><span class="n">taillag</span><span class="p">)</span><span class="o">/</span><span class="n">samples</span><span class="o">/</span><span class="n">z</span>
            <span class="n">allacf</span><span class="p">[:,</span> <span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">acf</span>
        <span class="k">if</span> <span class="n">partial</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_pacf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">allacf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_results</span><span class="p">[</span><span class="n">chainName</span> <span class="o">+</span> <span class="s2">&quot;_acf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">allacf</span></div></div>
                    
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2020 - present, Tom Werner.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>